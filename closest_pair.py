# -*- coding: utf-8 -*-
"""closest_pair.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wSsJug1mFkjjj38sQGhQE2klBNT0uua1
"""

import math
import random
import time
import matplotlib.pyplot as plt

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def compareX(a, b):
    p1 = a
    p2 = b
    return (p1.x - p2.x)

def compareY(a, b):
    p1 = a
    p2 = b
    return (p1.y - p2.y)

def dist(p1, p2):
    return math.sqrt((p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y))

def bruteForce(P, n):
    min_dist = float("inf")
    for i in range(n):
        for j in range(i+1, n):
            if dist(P[i], P[j]) < min_dist:
                min_dist = dist(P[i], P[j])
    return min_dist

def min(x, y):
    return x if x < y else y

def stripClosest(strip, size, d):
    min_dist = d
    strip = sorted(strip, key=lambda point: point.y)

    for i in range(size):
        for j in range(i+1, size):
            if (strip[j].y - strip[i].y) >= min_dist:
                break
            if dist(strip[i], strip[j]) < min_dist:
                min_dist = dist(strip[i], strip[j])
    return min_dist

def closestUtil(P, n):
    if n <= 3:
        return bruteForce(P, n)
    mid = n//2
    midPoint = P[mid]
    dl = closestUtil(P, mid)
    dr = closestUtil(P[mid:], n - mid)
    d = min(dl, dr)
    strip = []
    for i in range(n):
        if abs(P[i].x - midPoint.x) < d:
            strip.append(P[i])
    return min(d, stripClosest(strip, len(strip), d))

def closest(P, n):
    P = sorted(P, key=lambda point: point.x)
    return closestUtil(P, n)

def generate_random_points(num_points, range_x, range_y):
    return [Point(random.uniform(range_x[0], range_x[1]), random.uniform(range_y[0], range_y[1])) for _ in range(num_points)]

def run_multiple_tests(min_points, max_points, step):
    results = []

    for num_points in range(min_points, max_points + 1, step):
        range_x = (0, 1000)
        range_y = (0, 1000)
        points = generate_random_points(num_points, range_x, range_y)

        start_time = time.time()
        closest(points, num_points)
        end_time = time.time()

        results.append((num_points, end_time - start_time))

    return results

def plot_results(results):
    num_points, execution_time = zip(*results)

    plt.plot(num_points, execution_time, linestyle='-', color='b')
    plt.title('Зависимость времени выполнения от количества точек')
    plt.xlabel('Количество точек')
    plt.ylabel('Время выполнения (секунды)')
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    min_points_test = 10000
    max_points_test = 100000
    step_test = 10000

    results = run_multiple_tests(min_points_test, max_points_test, step_test)
    plot_results(results)

import math
import random
import time
import matplotlib.pyplot as plt

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def compareX(a, b):
    p1 = a
    p2 = b
    return (p1.x - p2.x)

def compareY(a, b):
    p1 = a
    p2 = b
    return (p1.y - p2.y)

def dist(p1, p2):
    return math.sqrt((p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y))

def bruteForce(P, n):
    min_dist = float("inf")
    for i in range(n):
        for j in range(i+1, n):
            if dist(P[i], P[j]) < min_dist:
                min_dist = dist(P[i], P[j])
    return min_dist

def min(x, y):
    return x if x < y else y

def stripClosest(strip, size, d):
    min_dist = d
    strip = sorted(strip, key=lambda point: point.y)

    for i in range(size):
        for j in range(i+1, size):
            if (strip[j].y - strip[i].y) >= min_dist:
                break
            if dist(strip[i], strip[j]) < min_dist:
                min_dist = dist(strip[i], strip[j])
    return min_dist

def naive_closest(P, n):
    min_dist = float("inf")
    for i in range(n):
        for j in range(i+1, n):
            if dist(P[i], P[j]) < min_dist:
                min_dist = dist(P[i], P[j])
    return min_dist

def generate_random_points(num_points, range_x, range_y):
    return [Point(random.uniform(range_x[0], range_x[1]), random.uniform(range_y[0], range_y[1])) for _ in range(num_points)]

def run_multiple_tests(min_points, max_points, step):
    results = []

    for num_points in range(min_points, max_points + 1, step):
        range_x = (0, 1000)
        range_y = (0, 1000)
        points = generate_random_points(num_points, range_x, range_y)

        start_time = time.time()
        naive_closest(points, num_points)
        end_time = time.time()

        results.append((num_points, end_time - start_time))

    return results

def plot_results(results):
    num_points, execution_time = zip(*results)

    plt.plot(num_points, execution_time, linestyle='-', color='b')
    plt.title('Зависимость времени выполнения от количества точек')
    plt.xlabel('Количество точек')
    plt.ylabel('Время выполнения (секунды)')
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    min_points_test = 10000
    max_points_test = 50000
    step_test = 10000

    results = run_multiple_tests(min_points_test, max_points_test, step_test)
    plot_results(results)